#=
the genPlasticWeights plugin defines the connectivity of the learned synapses.
this file is the default, and for each neuron simply chooses a random Lexc + Linh
as presynaptic partners and sets their initial weights to predefined values.
=#

#=
this is the sole plugin to input a variable other than just the user-defined
arguments.  specifically, it also inputs the number of spikes generated by the
static connectivity alone (called ns0 in the code).

returned are a matrix and two vectors of vectors specifying the plastic
connectivity.

the returned matrix (called wpWeightX in the source code) is Ncells x LX
and contains the (initial) weights of the external presynaptic neurons.

the vectors (wpWeightIn and wpIndexIn), each of length Ncells, contain
a vector for each neuron of the weights and indices of the recurrent
presynaptic neurons.
=#

function genPlasticWeights(args, ns0)
    @unpack Ncells, frac, Ne, Lexc, Linh, LX, wpee, wpie, wpei, wpii, wpX, rng, seed = args

    num_threads = Threads.nthreads()
    copy_rng = [typeof(rng)() for _=1:num_threads];
    isnothing(seed) || Random.seed!.(copy_rng, seed .+ (1:num_threads))
    save(joinpath(data_dir,"rng-genPlasticWeights.jld2"), "rng", copy_rng)

    # order neurons by their firing rate
    frac_cells = round(Int, frac*Ne)
    exc_ns0 = ns0[1:Ne]
    inh_ns0 = ns0[Ne+1:Ncells]
    exc_ordered = sortperm(exc_ns0)
    inh_ordered = collect(Ne+1:Ncells)[sortperm(inh_ns0)]
    exc_selected = sort(exc_ordered[end-frac_cells+1:end])
    inh_selected = sort(inh_ordered[end-frac_cells+1:end])
    
    # define weights_plastic
    wpIndexIn = Vector{Vector{Int}}(undef, Ncells)
    wpWeightIn = Vector{Vector{eltype(wpee)}}(undef, Ncells)

    # select random exc and inh presynaptic neurons
    Threads.@threads :static for i=1:Ncells
        # (1) select consecutive neurons from a random starting point
        # rnd_start = rand(1:length(exc_selected)-Lexc-Linh+1)
        # indE = sort(exc_selected[rnd_start:rnd_start+Lexc-1])
        # indI = sort(inh_selected[rnd_start:rnd_start+Linh-1])

        # (2) select random neurons
        indE = sample(copy_rng[Threads.threadid()], exc_selected, Lexc, replace=false)
        indI = sample(copy_rng[Threads.threadid()], inh_selected, Linh, replace=false)

        # build wpIndexIn
        wpIndexIn[i] = [indE; indI]

        # initial exc and inh plastic weights
        wpWeightIn[i] = Array{eltype(wpee)}(undef, Lexc+Linh)
        if i <= Ne
            wpWeightIn[i][1:Lexc] .= wpee
            wpWeightIn[i][Lexc+1:end] .= wpei
        else
            wpWeightIn[i][1:Lexc] .= wpie
            wpWeightIn[i][Lexc+1:end] .= wpii
        end
    end

    # define feedforward weights to all neurons
    #       - wpWeightX = randn(Ncells, LX) * wpX
    #       - initial weights, wpX = 0
    wpWeightX = randn(copy_rng[1], Ncells, LX) * wpX
    
    return wpWeightX, wpWeightIn, wpIndexIn
end
